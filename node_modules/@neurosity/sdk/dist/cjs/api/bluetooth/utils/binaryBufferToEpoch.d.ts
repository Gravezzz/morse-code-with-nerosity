import { Observable, UnaryFunction } from "rxjs";
import { Buffer } from "buffer/index.js";
import { Sample } from "../../../types/sample";
import { Epoch } from "../../../types/epoch";
import { DeviceInfo } from "../../../types/deviceInfo";
/**
 * @hidden
 */
export declare function binaryBufferToEpoch(deviceInfo: DeviceInfo): UnaryFunction<Observable<Epoch>, any>;
/**
 * @hidden
 */
export declare function binaryBufferToSamples(channelCount: number): UnaryFunction<any, any>;
/**
 * @hidden
 *
 * Decode the supplied Buffer as a list of Sample.
 *
 * Supplied buffer's length must be multiple of
 * `encodedSampleSize(channelCount)`.
 *
 * NB: This method does not guarantee validity of decoded samples. When
 * supplied with a buffer of appropriate length, it will always return a
 * matching number of Sample8. Since the encoding protocol defines no
 * metadata/checksum, correctness must be guaranteed via test coverage.
 *
 * @param buffer Buffer with binary payload to decode.
 * @param channelCount Number of expected channels in each sample.
 *
 * @returns List of decoded Samples present in buffer.
 */
export declare function decode(buffer: Buffer, channelCount: number): Array<Sample>;
/**
 * @hidden
 *
 * Calculate the size of each sample based on the number of channels.
 *
 * Each sample has the following 3 segments:
 * - Timestamp: 8 bytes (UInt64); contains current time in millis since epoch)
 * - Marker: 2 bytes (UInt16); for classifier data
 * - Data: N * 8 bytes (Double), each entry representing data from a different
 *   electrode.
 *
 *  +-----------+--------+------------------+
 *  | timestamp | marker | data (e1 ... eN) |
 *  +-----------+--------+------------------+
 *
 * The number of entries for Data varies per hardware model. It can be assumed
 * to remain constant for the lifetime of the program.
 */
export declare function encodedSampleSize(channelCount: number): number;
