"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCloudMetric = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const whileOnline_1 = require("./whileOnline");
const subscription_1 = require("./subscription");
/**
 * @internal
 */
function getCloudMetric(dependencies, subscription) {
    const { options, cloudClient, onDeviceChange, status } = dependencies;
    const { metric, labels, atomic } = subscription;
    const metricError = (0, subscription_1.validate)(metric, labels, options);
    if (metricError) {
        return (0, rxjs_1.throwError)(() => metricError);
    }
    const metric$ = new rxjs_1.Observable((observer) => {
        const subscriptions = atomic
            ? [
                cloudClient.metrics.subscribe({
                    metric: metric,
                    labels: labels,
                    atomic: atomic
                })
            ]
            : labels.map((label) => {
                return cloudClient.metrics.subscribe({
                    metric: metric,
                    labels: [label],
                    atomic: atomic
                });
            });
        const subscriptionWithListeners = subscriptions.map((subscription) => ({
            subscription,
            listener: cloudClient.metrics.on(subscription, (...data) => {
                observer.next(...data);
            })
        }));
        return () => {
            subscriptionWithListeners.forEach(({ subscription, listener }) => {
                cloudClient.metrics.unsubscribe(subscription, listener);
            });
        };
    });
    return onDeviceChange().pipe((0, operators_1.switchMap)((device) => {
        if (!device) {
            return rxjs_1.EMPTY;
        }
        return metric$.pipe((0, whileOnline_1.whileOnline)({
            status$: status(),
            allowWhileOnSleepMode: false
        }));
    }));
}
exports.getCloudMetric = getCloudMetric;
