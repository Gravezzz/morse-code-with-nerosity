/**
 * Annotates stream with user-defined metadata
 * @method addInfo
 * @example eeg$.pipe(addinfo({ samplingRate: 256, channelNames: ["Af7", "Fp1", "Fp2", "Af8"] })
 * @param {Object} info Info to be added to the EEG stream. Relevant info may include: `samplingRate` and `channelNames`
 * @returns {Observable<Sample|Epoch|PSD>}
 */
export declare const addInfo: (infoValue: any) => import("rxjs").UnaryFunction<import("rxjs").Observable<any>, import("rxjs").Observable<any>>;
/**
 * Takes an array or RxJS buffer of EEG Samples and returns an Epoch.
 * @method bufferToEpoch
 * @example eeg$.pipe(bufferTime(1000), bufferToEpoch({ samplingRate: 256 }))
 *
 * @param {Object} options - Data structure options
 * @param {number} [options.samplingRate] Sampling rate
 * @param {string} [options.dataProp='data'] Name of the key associated with eeg data
 *
 * @returns {Observable<Epoch>}
 */
export declare const bufferToEpoch: ({ samplingRate, dataProp }?: {
    samplingRate?: number;
    dataProp?: string;
}) => import("rxjs").UnaryFunction<import("rxjs").Observable<unknown>, import("rxjs").Observable<{
    [x: string]: any;
    info: any;
}>>;
/**
 * Converts a stream of individual Samples of EEG data into a stream of Epochs of a given duration emitted at specified interval. This operator functions similarly to a circular buffer internally and allows overlapping Epochs of data to be emitted (e.g. emitting the last one second of data every 100ms).
 * @method epoch
 * @example eeg$.pipe(epoch({ duration: 1024, interval: 100, samplingRate: 256 }))
 * @param {Object} options - Epoching options
 * @param {number} [options.duration=256] Number of samples to include in each epoch
 * @param {number} [options.interval=100] Time (ms) between emitted Epochs
 * @param {number} [options.samplingRate=256] Sampling rate
 * @param {string} [options.dataProp='data'] Name of the key associated with eeg data
 * @returns {Observable} Epoch
 */
export declare const epoch: ({ duration, interval, samplingRate, dataProp }: {
    duration: any;
    interval: any;
    samplingRate: any;
    dataProp?: string;
}) => import("rxjs").UnaryFunction<import("rxjs").Observable<unknown>, import("rxjs").Observable<{
    [x: string]: any;
    info: any;
}>>;
